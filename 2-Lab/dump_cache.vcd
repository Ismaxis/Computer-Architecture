$date
	Wed Nov 30 17:15:41 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 3 ! cpu_command [2:0] $end
$var wire 16 " cpu_data [15:0] $end
$var wire 16 # mem_data [15:0] $end
$var wire 2 $ mem_command [1:0] $end
$var wire 15 % mem_address [14:0] $end
$var wire 15 & cpu_address [14:0] $end
$var reg 1 ' clk $end
$var reg 1 ( reset $end
$scope module cache $end
$var wire 1 ' clk $end
$var wire 3 ) cpu_command [2:0] $end
$var wire 16 * cpu_data [15:0] $end
$var wire 15 + mem_address [14:0] $end
$var wire 2 , mem_command [1:0] $end
$var wire 16 - mem_data [15:0] $end
$var wire 1 ( reset $end
$var wire 15 . cpu_address [14:0] $end
$var reg 3 / cpu_command_buff [2:0] $end
$var reg 16 0 cpu_data_bus_buff [15:0] $end
$var reg 4 1 cpu_offset_buff [3:0] $end
$var reg 5 2 cpu_set_buff [4:0] $end
$var reg 10 3 cpu_tag_buff [9:0] $end
$var reg 3 4 cur_cpu_command [2:0] $end
$var reg 1 5 index_in_set $end
$var reg 15 6 mem_address_buff [14:0] $end
$var reg 2 7 mem_command_buff [1:0] $end
$var reg 16 8 mem_data_buff [15:0] $end
$var reg 128 9 mem_line_buff [127:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 : i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop2 $end
$var integer 32 ; i [31:0] $end
$upscope $end
$scope task delay $end
$upscope $end
$scope task read_cpu_address $end
$upscope $end
$scope task read_from_storage $end
$upscope $end
$scope task store $end
$upscope $end
$scope task write_to_MM $end
$scope begin $ivl_for_loop0 $end
$var integer 32 < i [31:0] $end
$upscope $end
$upscope $end
$scope task write_to_storage $end
$upscope $end
$upscope $end
$scope module cpu $end
$var wire 1 ' clk $end
$var wire 3 = command [2:0] $end
$var wire 16 > data [15:0] $end
$var wire 15 ? address [14:0] $end
$var reg 19 @ cpu_address_buff [18:0] $end
$var reg 3 A cpu_command_buff [2:0] $end
$var reg 16 B data_to_write [15:0] $end
$var reg 16 C recieved_data [15:0] $end
$scope task delay $end
$upscope $end
$upscope $end
$scope module mem $end
$var wire 15 D address [14:0] $end
$var wire 1 ' clk $end
$var wire 2 E command [1:0] $end
$var wire 16 F data [15:0] $end
$var wire 1 ( reset $end
$var reg 2 G command_buff [1:0] $end
$var reg 16 H data_buff [15:0] $end
$var reg 4 I rwPosition [3:0] $end
$var integer 32 J SEED [31:0] $end
$scope begin $ivl_for_loop3 $end
$var integer 32 K i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop4 $end
$var integer 32 L i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop5 $end
$var integer 32 M i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 M
b0 L
b0 K
b110111000011110110 J
bx I
bx H
bx G
bx F
bz E
bx D
b0 C
bz B
bz A
bx @
bx ?
bz >
bz =
b0 <
b0 ;
b0 :
b0 9
bz 8
bz 7
bx 6
x5
b0 4
bx 3
bx 2
bx 1
bz 0
bz /
bx .
bx -
bz ,
bx +
bz *
bz )
0(
x'
bx &
bx %
bz $
bx #
bz "
bz !
$end
#1
b0 I
b0 G
bz #
bz -
bz F
bz H
b1100011 K
b110000110000011110001000101 J
b100000 :
1(
#2
b10 &
b10 .
b10 ?
b10 @
b1 !
b1 )
b1 =
b1 A
0'
0(
#3
b10 2
b0 3
b10 %
b10 +
b10 D
b10 6
b1 4
1'
#4
b0 &
b0 .
b0 ?
b0 @
0'
#5
1'
#6
b10 $
b10 ,
b10 E
b10 7
b0 1
bz !
bz )
bz =
bz A
0'
#7
b10 I
b10000 L
b1000000111100 #
b1000000111100 -
b1000000111100 F
b1000000111100 H
1'
#8
b1000000111100 9
0'
#9
b100 I
b0 #
b0 -
b0 F
b0 H
b10000 L
1'
#10
b1 ;
0'
#11
b110 I
b10000 L
1'
#12
b10 ;
0'
#13
b1000 I
b10000 L
1'
#14
b11 ;
0'
#15
b1010 I
b10000 L
1'
#16
b100 ;
0'
#17
b1100 I
b10000 L
1'
#18
b101 ;
0'
#19
b1110 I
b10000 L
1'
#20
b110 ;
0'
#21
b0 I
b10000 L
1'
#22
b111 ;
0'
#23
b10 I
b1000000111100 #
b1000000111100 -
b1000000111100 F
b1000000111100 H
b10000 L
1'
#24
b111 !
b111 )
b111 =
b111 /
b111100 "
b111100 *
b111100 >
b111100 0
05
b0 $
b0 ,
b0 E
b0 7
b1000 ;
0'
#25
bz #
bz -
bz F
bz H
b0 I
1'
#26
b10 &
b10 .
b10 ?
bz 4
bz 0
bz /
b101010101010101 "
b101010101010101 *
b101010101010101 >
b101010101010101 B
b10 @
b101 !
b101 )
b101 =
b101 A
b111100 C
0'
#27
b101 4
1'
#28
b0 &
b0 .
b0 ?
b0 @
0'
#29
1'
#30
b111 /
b111 !
b111 )
b111 =
bz A
0'
#31
1'
#32
b10 &
b10 .
b10 ?
bz 4
bz /
b10 @
b10 !
b10 )
b10 =
b10 A
bz "
bz *
bz >
bz B
0'
#33
b10 4
1'
#34
b0 &
b0 .
b0 ?
b0 @
0'
#35
1'
#36
b111 /
b1000001010101 "
b1000001010101 *
b1000001010101 >
b1000001010101 0
b111 !
b111 )
b111 =
bz A
0'
#37
1'
#38
b10 &
b10 .
b10 ?
bz 4
bz 0
bz /
b101010101010101 "
b101010101010101 *
b101010101010101 >
b101010101010101 B
b10 @
b110 !
b110 )
b110 =
b110 A
b1000001010101 C
0'
#39
b110 4
1'
#40
b0 &
b0 .
b0 ?
b0 @
0'
#41
1'
#42
b111 /
b111 !
b111 )
b111 =
bz A
0'
#43
1'
#44
b10 &
b10 .
b10 ?
bz 4
bz /
b10 @
b10 !
b10 )
b10 =
b10 A
bz "
bz *
bz >
bz B
0'
#45
b10 4
1'
#46
b0 &
b0 .
b0 ?
b0 @
0'
#47
1'
#48
b111 /
b101010101010101 "
b101010101010101 *
b101010101010101 >
b101010101010101 0
b111 !
b111 )
b111 =
bz A
0'
#49
1'
#50
bz 4
bz "
bz *
bz >
bz 0
bz !
bz )
bz =
bz /
b101010101010101 C
0'
